#!/usr/bin/env python3

from math import floor
from random import randint

# Messages for certain status effects ocurring
StatusMessages = {
"FOCUS": " aims carefully!",
"DEFEND": " defends!"
}

StatusTypes = ["ATK_BUFF", "DEF_BUFF", "DOT"]

class Status:
	# Defines a status effect
	def __init__(self, type, name, modifier):
		if type in StatusTypes:
			self.type = type
			self.name = name
			self.modifier = modifier
			self.lifeTime = 0
	def setLife(self, life):
		self.lifeTime = life

# Performs an attack calculation
def Attack(source, target):
	# Start with base multiplier of 1
	ATK_Multiplier = 1
	# Add positive attack modifiers (ATK_BUFFs)
	for status in source.status:
		if status.type is "ATK_BUFF":
			# Decrements lifetime counter for the buff, or removes it if it has timed out
			if status.lifeTime == 0:
				(source.status).remove(status)
			else:
				status.lifeTime -= 1

			# Prints out the buff's message
			print(str(source.name) + StatusMessages[status.name])
			ATK_Multiplier += status.modifier
	# Checks for negative attack modifiers (DEF_BUFFs)
	for status in target.status:
		if status.type is "DEF_BUFF":
			ATK_Multiplier -= status.modifier
			if status.lifeTime == 0:
				(target.status).remove(status)
			else:
				status.lifeTime -= 1
			print(str(target.name) + StatusMessages[status.name])
	trueATK = source.ATK
	# Checks for equipped items in invenntory, adds them to base attack if equipped
	#	and they have an ATK modifier
	for item in source.inventory:
		if hasattr(item, 'equipped') and item.equipped == 1:
			trueATK += item.ATK

	# Generates random number from 0 to trueATK, multiplies by the attack modifier
	damage = floor(randint(0, trueATK) * ATK_Multiplier)
	
	# Seperate message for no damage
	if damage <= 0:
		print(str(source.name) + " attacks, and " + str(target.name) + " takes no damage")
	# Otherwise prints out how much damage was dealth, decrements target HP
	else:
		target.HP -= damage
		if target.HP < 0:
			target.HP = 0
		print(str(source.name) + " attacks, " + str(target.name) + " is hit for " + str(damage) + " points of damage")
	return

# Applies the DEFEND status effect on the given ENT
def Defend(source):
	# Removes ATK_BUFF statuses
	if any(status.name == "FOCUS" for status in source.status):
		print(str(source.name) + " loses its focus")
	for status in [status for status in source.status if status.type is "ATK_BUFF"]:
		(source.status).remove(status)
	# Checks to see if the ENT is already defending first
	if not any(status.name == "DEFEND" for status in source.status):
		# Prints message, applies status effect	
		print(str(source.name) + " braces for the next attack!")
		(source.status).append(Status("DEF_BUFF", "DEFEND", 0.75))
	else:
		print(str(source.name) + " continues defending")

# Applies the FOCUS status effect on the given ENT
def Focus(source):
	# If not already focused, adds the effect w/ a +100% strength
	if not any(status.name == "FOCUS" for status in source.status):
		(source.status).append(Status("ATK_BUFF", "FOCUS", 1))
		print(str(source.name) + " begins focusing!")
	else:
		# Otherwises find it and increases its strength
		for status in source.status:
			if status.name == "FOCUS":
				if status.modifier < 4:
					# Buff gets stronger the more times it is applied
					#	starting at 100%, then 200%, then 400%
					status.modifier *= 2
					if status.modifier >= 4:
						print(str(source.name) + "'s focus reaches its peak!")
					else:
						print(str(source.name) + " intensifies their focus!")
				else:
					# If buff is already at max strength, say so
					print(str(source.name) + " can't focus any harder!")

# Represents an item, which may or may not be equippable
class Item:
	# Prints out item name, and whether it is equipped
	def __str__(self):
		if self.name.startswith(('a', 'e', 'i', 'o', 'u')):
			toReturn += "An "
		else:
			toReturn += "A "
		toReturn += str(self.name)
		if hasattr(self, 'equipped') and self.equipped == 1:
			toReturn += ", that you are currently holding"
		return toReturn

	def __init__(self):
		self.name = ""
		self.ATK = 0

# Generates a weapon from a dictionary generated by record_jar_reader
def GenWeapon(dict):
	toReturn = Item()
	try:
		toReturn.name = dict['Name']
		toReturn.ATK = int(dict['Attack'])
		toReturn.equipped = 0
	# If dict is malformed, fails softly
	except KeyError:
		pass
	return toReturn

class Monster:
	def __str__(self):
		toReturn = "Name: " + self.name + " HP: " + str(self.HP)  + "/" + str(self.Max_HP)
		return toReturn

	def __init__(self):
		self.ATK = 0
		self.Max_HP = 0
		self.HP = 0
		self.name = "None"
		self.status = []
		self.inventory = []
		self.actions = []
		self.targets = []

# Generates a monster from a dictionary generated by record_jar_reader
def GenMonster(dict):
	toReturn = Monster()
	try:
		toReturn.ATK = int(dict['Attack'])
		toReturn.Max_HP = int(dict['Health'])
		toReturn.HP = int(dict['Health'])
		toReturn.name = dict['Name']
	except KeyError:
		pass
	toReturn.actions = [Attack, Defend, Focus]
	return toReturn

class Player:
	def __init__(self):
		self.name = "Player"
		self.Max_HP = 0
		self.HP = 0
		self.ATK = 0
		self.status = []
		self.actions = []
		self.inventory = []

	def __str__(self):
		toReturn = "You, " + self.name + ", have " + str(self.HP) + "/" + str(self.Max_HP) + " HP"
		return toReturn

	# Prints ou the player's inventory, along with the slot number
	def PrintInventory(self):
		print("Your bag contains:")
		if len(self.inventory) == 0:
			print("Nothing!")
			return
		else:
			i = 1
			for item in self.inventory:
				print("[" + str(i) + "] " + str(item))

def GenPlayer(name, HP, ATK):
	toReturn = Player()
	toReturn.name = name
	toReturn.HP = HP
	toReturn.Max_HP = HP
	toReturn.ATK = ATK
	return toReturn

def Heal(ent, amt):
	ent.HP += amt
	if ent.HP > ent.Max_HP:
		ent.HP = ent.Max_HP

# Places the given item into the user's inventory at the end
def GiveItem(ent, item):
	ent.inventory.append(item)
	if type(ent) == type(Player()):
		print("You pick up the " + str(item.name) + " and place it in slot " + str(len(ent.inventory)))

# Removes the item in the given slot number
def DropItem(ent, slot):
	if slot > 0 and slot <= len(ent.inventory):
		try:
			print("You drop your " + str(ent.inventory.pop(i - 1).name))
		except IndexError:
			print("You don't have anything in that slot to drop!")

# Equips the item in the given slot number
def EquipItem(ent, slot):
	if slot > 0 and slot <= len(ent.inventory):
		if hasattr(ent.inventory[slot - 1], 'equipped') and ent.inventory[slot - 1].equipped == 1:
			print("You are already holding your " + str(ent.inventory[slot -  1].name))
			return
		elif not hasattr(ent.inventory[slot - 1], 'equipped'):
			print("You can't equip a(n) " + str(ent.inventory[slot - 1].name) + "!")
			return
		elif any(hasattr(item, 'equipped') and item.equipped == 1 for item in ent.inventory):
			for item in ent.inventory:
				if hasattr(item, 'equipped') and item.equipped == 1:
					print("You unequip your " + str(item.name))
					item.equipped = 0
		print("You equip your " + str(ent.inventory[slot - 1].name))	
		ent.inventory[slot - 1].equipped = 1
	else:
		print("You don't have anything in that slot!")
